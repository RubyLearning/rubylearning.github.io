<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <title>
    &#34;AkitaOnRails&#34; On Anatomy of Ruby Blocks/Closures // RubyLearning Blog
  </title>

  <link href="http://gmpg.org/xfn/11" rel="profile">
<meta http-equiv="content-type" content="text/html; charset=utf-8">


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

<meta name="description" content="">
<meta name="googlebot" content="nofollow">
<meta name="keywords" content="">
<meta name="author" content="Fabio Akita">


  <meta property="og:title" content="&#34;AkitaOnRails&#34; On Anatomy of Ruby Blocks/Closures" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:locale" content="en_US" />
<meta property="og:url" content="http://rubylearning.com/blog/2007/11/30/akitaonrails-on-anatomy-of-ruby-blocks/closures/" />


  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/base-min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/pure-min.css">
  
  
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/grids-responsive-min.css">
  
  

  <link rel="stylesheet" href="http://rubylearning.com/blog//css/redlounge.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='//fonts.googleapis.com/css?family=Raleway:400,200,100,700,300,500,600,800' rel='stylesheet' type='text/css'>
  <link href='//fonts.googleapis.com/css?family=Libre+Baskerville:400,700,400italic' rel='stylesheet' type='text/css'>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="RubyLearning Blog" />

    
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.7/styles/tomorrow-night-bright.min.css">
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.7/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>


  

  

  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', "UA-59044-10", 'auto');
  ga('send', 'pageview');
</script>

</head>

<body>
	

	<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
  <div class="header">
    

	

    <h1 class="brand-title">Ruby Learning</h1>
    <h2 class="brand-tagline">Not Just Ruby Any More!</h2>

    <nav class="nav">
      <ul class="nav-list">
        <li class="nav-item"><span class="nav-item-separator">//</span><a href="http://rubylearning.com/blog/">Home</a></li>
        
          <li class="nav-item"><span class="nav-item-separator">//</span><a href="http://rubylearning.com/">Hub</a></li>
        
          <li class="nav-item"><span class="nav-item-separator">//</span><a href="http://rubylearning.org">Online Course</a></li>
        
          <li class="nav-item"><span class="nav-item-separator">//</span><a href="http://satishtalim.com/">Satish</a></li>
        
          <li class="nav-item"><span class="nav-item-separator">//</span><a href="http://rubylearning.com/satishtalim/tutorial.html">Tutorial</a></li>
        
      </ul>
    </nav>

    

  </div>
</div>

	
	

    <div class="content pure-u-1 pure-u-md-3-4">
		<a name="top"></a>
		

		
			
	    
  		<section class="post">
            <h1 class="post-title">
              <a href="/blog/2007/11/30/akitaonrails-on-anatomy-of-ruby-blocks/closures/">&#34;AkitaOnRails&#34; On Anatomy of Ruby Blocks/Closures</a>
            </h1>
            <h3 class="post-subtitle">
            	
            </h3>
            
            	<span class="post-date">
                	<span class="post-date-day"><sup>30</sup></span><span class="post-date-separator">/</span><span class="post-date-month">Nov</span> <span class="post-date-year">2007</span>
            	</span>
            	
            
            	
            		<span class="post-author-single">By <a class="post-author"  target="">Fabio Akita</a></span>
            		




            	
            

			
			
				<div class="post-categories">
				
					<a class="post-category post-category-beginners" href="http://rubylearning.com/blog//categories/beginners">beginners</a>
				
					<a class="post-category post-category-rails" href="http://rubylearning.com/blog//categories/rails">rails</a>
				
					<a class="post-category post-category-ruby" href="http://rubylearning.com/blog//categories/ruby">ruby</a>
				
					<a class="post-category post-category-training" href="http://rubylearning.com/blog//categories/training">training</a>
				
				</div>
			

			

			

            <p><strong><em>Fabio Akita’s</em></strong> &ldquo;AkitaOnRails&rdquo; series at RubyLearning.com, for
would-be Ruby developers, has been quite a hit. Today in another
article, Fabio talks in depth about Ruby’s <strong>Blocks/Closures</strong>, This is
a rather long article but well worth the time invested in reading it.
The entire source code for the programs in this article is available
<a href="http://tinyurl.com/2zjgjb">here</a>.</p>

<p><img src="http://www.rubylearning.com/images/akita.jpg" alt="Fabio
Akita" title="Fabio Akita" />
<strong>Fabio
Akita</strong> is a Brazilian Rails enthusiast, also known online as
“AkitaOnRails”. He regularly write posts on his own
<a href="http://www.akitaonrails.com/">blog</a> and had published the very first
book tailored for the Brazilian audience called “Repensando a Web com
Rails”. He is now a full-time Ruby on Rails developer working as Brazil
Rails Practice Manager for the Utah company Surgeworks LLC.</p>

<p><strong>Note</strong>: You may want to brush up on <a href="http://rubylearning.com/satishtalim/ruby_blocks_and_procs.html">Ruby Blocks and
Procs</a>
before going through Fabio’s article.</p>

<p><strong>Fabio&gt;&gt;</strong> There is no Rubyism more difficult to explain, than a
Closure. I could write an entire book about it. Instead of boring
everyone to death with academics, I’ll try to focus only on what one
really needs for day-to-day activities.</p>

<p>Let’s start with an example:</p>

<pre><code># program1.rb
for i in [1,2,3,4]
  puts i
end

a = 0
b = [1,2,3,4]
while a &lt; b.length
  puts b[a]
  a += 1
end
</code></pre>

<p>These are very simple iterators, similar to what we have in several
languages. The first one with a ‘<strong>for</strong>‘ construct and the second with
the familiar ‘<strong>while</strong>‘ statement. Nothing fancy here. But let’s see
another way of accomplishing the same thing in Ruby:</p>

<pre><code># program2.rb
[1,2,3,4].each { |i| puts i }

[1,2,3,4].each do |i|
  puts i
end
</code></pre>

<p>Not too shabby, simpler and elegant, but that’s where people start
gasping. The pipes notation is particularly threatening for
non-starters. Both the brackets and the do..end notations define an
enclosed piece of code that we name as ‘blocks’ or ‘closures’. What’s
between the pipes are like parameters to a method. It ‘feels’ like this
pseudo-code:</p>

<pre><code>def unnamed_method(i)
  puts i
end

[1,2,3,4].each(unnamed_method)
</code></pre>

<p>This is not valid Ruby code, of course. That’s similar to what we would
do in C# with delegates. We have something similar in JavaScript (using
the &ldquo;Prototype&rdquo; <a href="http://www.prototypejs.org/api/enumerable/each">http://www.prototypejs.org/api/enumerable/each</a>
library):</p>

<pre><code>[1,2,3,4].each(function(i) {
  alert(i);
});
</code></pre>

<p>In Javascript functions are first-class citizens of the language and
they can be defined anonymously (without a name), and then passed as
parameters to another function. We can manipulate and move functions all
over the place.</p>

<p>Ruby doesn’t have methods as first-class citizens. We actually can
extract a method from an object and wrap it around a ‘<strong>Method</strong>‘
object, but it holds the context of its object, so it is not
independent.</p>

<pre><code># program3.rb
class Test
  def initialize
    @hello = &quot;Hello!&quot;
  end
  def say
    @hello
  end
end

m = Test.new.method(:say)
puts m.call # =&gt; &quot;Hello!&quot;
puts m.class # =&gt; &quot;Method&quot;
</code></pre>

<p>Here, we extracted the :say method from the instantiated Test instance.
Notice that we can now manipulate the method as a normal object.
Whenever we send the ‘<strong>call</strong>‘ message to the method object, it runs as
if it was being executed from the context of the original object
(Test.new.say). In the above example the second last statement would
successfully print “Hello!”, as stored in the local instance variable
@hello.</p>

<p>Although simple, we don’t do this very often. That’s because this method
is bound to the original object’s context and we don’t usually want
that: it would be nice to have an independent block of code. So, let’s
create one very simple block of code referenced by a variable:</p>

<pre><code># program4.rb
c = lambda { |i| puts i }
c.call(1) # =&gt; 1
c.call(2) # =&gt; 2
</code></pre>

<p>The ‘<strong>lambda</strong>‘ keyword encloses the code within brackets as an object
block, an instance of the <strong>Proc</strong> class. This object responds to the
‘<strong>call</strong>‘ method. In the last two statements we pass parameters to the
‘<strong>call</strong>‘ method and it goes to the ‘i’ variable defined within pipes
inside the block. So, it acts as an independent entity, detached from
any particular class. Let’s test it:</p>

<pre><code># program5.rb
c = lambda { |i| puts i }

class Test
  def say(block)
    block.call(self.class)
  end
end

c.call(self.class) # =&gt; Object
Test.new.say(c)    # =&gt; Test
</code></pre>

<p>We’re using the same block defined above in the variable ‘c’. After the
definition of the Test class, we call the block object passing
‘self.class’ and it returns <strong>Object</strong> as a result. Then, we call the
:say method from inside an instance of the Test class. The :say method
calls the block giving the inner ‘self.class’ as a block parameter. In
this case it prints out ‘Test’ instead of ‘<strong>Object</strong>‘, meaning that the
block binds itself to the enclosing scope. That’s one difference between
a block and a detached object method.</p>

<p>In many ways, Blocks resembles anonymous functions from Javascript,
anonymous delegates from C#, anonymous inner classes from Java. This is
a very useful construct that was primarily created to better handle
iterators. For instance:</p>

<pre><code># program6.rb
[1,2,3,4].reverse_each { |i| puts i }
# =&gt; 4 
# =&gt; 3
# =&gt; 2
# =&gt; 1
</code></pre>

<p>Now, this is different from the Array’s ‘<strong>each</strong>‘ method we used
before. ‘<strong>reverse_each</strong>‘ navigates backwards through the Array’s
elements. It gets each element and passes it into the ‘i’ variable, set
as a parameter for the block defined within brackets.</p>

<p>In languages like Java, everything has to be defined through an
interface. Enumerators are no different, and we have interfaces like
‘Iterator’. This method defines simple methods as ‘hasNext()’ and
‘next()’. But what if we actually need something as a reverse iterator?
Now we’re on our own. What if we need something more complicated like an
iterator that only walks through even elements? In Ruby we can define
such a method like this:</p>

<pre><code># program7.rb
class Array
  def even
    i = 0
    while i &lt; self.size
      yield(self[i]) if i % 2 == 0
      i += 1
    end
  end
end

[1,2,3,4,5,6].even { |i| puts i }
# =&gt; 1
# =&gt; 3
# =&gt; 5
</code></pre>

<p>First of all, remember that Ruby’s classes are all open, so we can
easily redefine the standard <strong>Array</strong> class and append new methods to
it. Now pay attention to the ‘even’ method. We implement it the usual
way with a ‘while’ loop. But the interesting bit is the ‘<strong>yield</strong>‘
keyword. Pretend that it works like a *wildcard placeholder* for
blocks. In the example, when we pass the ‘self[i]’ value as its
parameter, we’re actually passing this value to the ‘i’ parameter in the
block.</p>

<p>We can rewrite this method in a slightly different way but with the same
behavior:</p>

<pre><code># program8.rb
class Array
  def even(&amp;code)
    i = 0
    while i &lt; self.size
      code.call( self[i] ) if i % 2 == 0
      i += 1
    end
  end
end
</code></pre>

<p>So, now we explicitly defined that the ‘even’ method expects to receive
a block, converting it to the ‘code’ parameter. Then, inside it we send
the ‘<strong>call</strong>‘ method to ‘code’ and pass ‘self[i]’ as its parameter. The
result is exactly the same as using the <strong>yield</strong> keyword.</p>

<p>We can still do it differently:</p>

<pre><code># program9.rb
class Array
  def even(block)
    i = 0
    while i &lt; self.size
      block.call( self[i] ) if i % 2 == 0
      i += 1
    end
  end
end
</code></pre>

<p>Now we’re doing it without the ampersand in the parameter. In the
previous example, the ampersand operator ‘captures’ a block into a
<strong>Proc</strong> instance object. In the latest example, the ‘even’ method
expects to directly receive a <strong>Proc</strong> object, like this:</p>

<pre><code># program10.rb
class Array
  def even(block)
    i = 0
    while i &lt; self.size
      block.call( self[i] ) if i % 2 == 0
      i += 1
    end
  end
end
c = lambda { |i| puts i }
[1,2,3,4,5,6].even( c )
</code></pre>

<p>Let’s go back to the Array’s ‘<strong>each</strong>‘ method as we displayed before:</p>

<pre><code>c = lambda { |i| puts i }
[1,2,3,4].each( &amp;c )
</code></pre>

<p>A little bit different, because the ‘<strong>each</strong>‘ method doesn’t expect a
<strong>Proc</strong> object as a parameter, but an actual Block. So we use the
ampersand before the <strong>Proc</strong> instance variable and it kind of ‘expands’
it back into a ‘raw’ code block, so that the ‘even’ method can ‘yield’
it inside, instead of executing through the ‘<strong>call</strong>‘ method.</p>

<p>This usage of a <strong>Proc</strong> object is not as elegant as just passing a
Block, but with this construct we are storing code within an object. We
can define a method that receives as many blocks as we need, for
instance:</p>

<pre><code># program11.rb
def foo(name, block1, block2)
  block1.call
  puts name
  block2.call
end

foo &quot;Fabio&quot;, lambda { puts &quot;Hello&quot; }, lambda { puts &quot;World&quot; }
</code></pre>

<p>This example receives a normal parameter and 2 blocks instead of one. We
can pass blocks as enclosed <strong>Proc</strong> objects in the parameters list as
we would do with any other kind of object. We usually don’t need that
many discrete blocks inside a single method. The most usual style is:</p>

<pre><code># program12.rb
def foo( param1, param2 )
  # do something
  some_param = 1
  yield( some_param ) if block_given?
end

foo(1, 2) do |some_param|
  # do something
end
</code></pre>

<p>So we define a normal method, with normal parameters. But inside it we
ask ‘<strong>block_given?</strong>‘. If positive, it ‘yields’ its block passing some
parameter to it (of course, parameters are optional, and you can pass as
many parameters as you want to a block, even zero parameters).</p>

<p>We call the defined method as usual, passing a block at the end of the
method call. By the way, here’s another way of defining a block: using
the do .. end construct. There is no strict rule, but we reserve the
brackets notation when the block is small and we can state it in a
single line, and the do .. end notation when we have blocks with
multiple statements inside.</p>

<p>There’s a gotcha:</p>

<pre><code>foo a, b do |some_param|
  # do something
end

foo a, b { |some_param| # do something }
</code></pre>

<p>Both brackets and do .. end constructs define blocks, so at first glance
the 2 above statements seems to do the same thing. But the gotcha is
that in Ruby parenthesis are optional, and we’re not using them here.</p>

<p>In the first statement the block is assumed to be passed to the ‘foo’
method as expected, with ‘a’ and ‘b’ as normal parameters. But the
second statement guesses that ‘b’ is a method and tries to pass the
block to it. The recommendation is: if you have a method that needs both
parameters and a block, enclose the parameters within parenthesis to
avoid ambiguities.</p>

<p>We now understand that <strong>Blocks are pieces of code that can be exchanged
between method calls, as parameters or returned values</strong>. But there is
more to it:</p>

<pre><code># program13.rb
c = lambda { |i| puts i }
c = Proc.new { |i| puts i }
c = proc { |i| puts i }
</code></pre>

<p>The above 3 statements do the same thing: instantiate a block object.
‘proc’ is an alias for ‘<strong>lambda</strong>‘ and they work slightly different
than ‘<strong>Proc.new</strong>‘. In Ruby 1.9, ‘proc’ will probably be an alias for
‘<strong>Proc.new</strong>‘ instead.</p>

<p><strong>Keywords to keep in mind are</strong>:</p>

<ul>
<li><strong>lambda/Proc.new</strong> – encloses a bunch of code inside a <strong>Proc</strong>
instance.</li>
<li>&amp; – ampersand, either captures a ‘raw’ code block into a <strong>Proc</strong>
object or expands the <strong>Proc</strong> object as a ‘raw’ block.</li>
<li>{}/do..end – defines a code block.</li>
<li>|| – pipes, defines the parameters of a block. If you don’t need
any, just omit the pipes altogether.</li>
</ul>

<p>So, some people misinterpret Blocks as a simple function pointer, or
something like Java’s anonymous inner class. That’s not the case: and
here we finally boil down to “Closures”. Ruby Blocks are Closures. The
words ‘blocks’ and ‘closures’ mean the same thing in Ruby.</p>

<p>Ruby Blocks can enclose not only code and it’s own inner local
variables, but it can enclose the surrounding context variables. That’s
why it is called a ‘closure’. Let’s see an example:</p>

<pre><code># program14.rb
def greetings_factory(prefix)
  Proc.new { |name| &quot;#{prefix}, #{name} !&quot;}
end

birthday = greetings_factory(&quot;Happy Birthday&quot;)
xmas = greetings_factory(&quot;Merry XMas&quot;)

puts birthday.call(&quot;David&quot;) # =&gt; &quot;Happy Birthday, David !&quot;
puts xmas.call(&quot;Matz&quot;)      # =&gt; &quot;Merry XMas, Matz !&quot;
</code></pre>

<p>The first thing is a method definition for ‘greetings_factory’. It gets
a prefix as a parameter and returns a <strong>Proc</strong> object, whose inner
parameter is a name. So far so good.</p>

<p>The second part defines 2 <strong>Proc</strong> instances, one for birthday and
another for christmas. Notice that we pass 2 different prefixes into the
‘greetings_factory’ method. The different values are ‘closed’ within
Block. So, when we later call them, we see how differently they behave:
they actually stored the latest state within itself. So each block
stored the ‘prefix’ variable passed before, while still accepting the
‘name’ parameter within the Block.</p>

<p>Keep in mind that every Ruby Block is a Closure, that’s why this
construct actually works:</p>

<pre><code># program15.rb
list = []
[1,2,3,4].each do |i| 
  list &lt;&lt; i * 2 
end
puts list.inspect # =&gt; [2, 4, 6, 8]
</code></pre>

<p>So, we defined a ‘list’ array *before* we create the iterator block.
Then, inside the block we refer to the external ‘list’ array and
populate it. In Java, this would’ve been a final variable, but in Ruby
there is no such limitation.</p>

<p>You’d want to be very careful about the surroundings of your block: do
not define variables that’s going to be used inside the blocks too early
in the code. Try to keep dependencies nearby, like in the above example
where the ‘list’ Array is defined right before the iterator itself.</p>

<p>Iterators get a big boost because we’re not limited to a hard Interface.
We can add whatever methods we need, like ‘each’, ‘reverse_each’,
‘collect’, ‘select’ and so on. Each one of them can receive a block and
pass one element at a time to the user-defined block.</p>

<p>Another very important usage is to enclose widely used code patterns.
For example, Rails has the following construct to use database
transactions:</p>

<pre><code>User.transaction do 
  u = User.new(:login =&gt; 'admin')
  u.save!
end
</code></pre>

<p>‘User’ would be the <strong>ActiveRecord</strong> instance. One example of the
structure for the model’s ‘transaction’ class method would resemble this
structure:</p>

<pre><code>class ActiveRecord::Base
  def self.transaction
    begin
      ActiveRecord::Base.establish_connection
      yield if block_given?
    rescue =&gt; e
      RAILS_DEFAULT_LOGGER.error e
    ensure
      ActiveRecord::Base.remove_connection 
    end
  end
end
</code></pre>

<p>This means: open the database then try to ‘yield’ the block if provided.
If anything wrong happens, get the error message and log it. Finally
ensure that the connection is dropped after all this.</p>

<p><strong>ActiveRecord</strong> doesn’t open and close connections this often, but you
get the idea. But this is an overall big picture of one way to avoid
repetition and the extraction of common code patterns. So it’s clever to
encapsulate common functionality and place in a placeholder for
user-defined code in-between.</p>

<p>The <strong>File.open</strong> method does the same thing: it takes responsibility of
properly opening files, yielding the user block and ensuring that the
file is closed without the user having to manually do this kind of house
cleaning.</p>

<p>The most important
“concept”:<a href="http://martinfowler.com/bliki/Closure.html">http://martinfowler.com/bliki/Closure.html</a>
is that Blocks helps hiding implementation details. We don’t want to
know the inner details of a list iterator, or how a transaction works.
We just need to focus on the business logic itself, trapped within a
Block.</p>

<p>We described here a lot of stuff, and I think it covers the basics.
Enough to actually read some of the Rails source-code and get acquainted
for closure’s modus operandi. Hope you enjoyed this article!</p>

<p><em>Thank you Fabio for showing us a different perspective on Ruby Blocks.
In case you have any queries, questions on this article, kindly post
your questions here and Fabio would be glad to answer.</em></p>

	
			

			

			
				<div class="paging">
					<span class="paging-label">More Reading</span>
					
					<div class="paging-newer">
						<span class="dark-red">Newer</span><span class="decorative-marker">//</span>
						<a class="paging-link" href="/blog/2007/12/04/josh-software-making-its-mark-in-ruby-on-rails/">Josh Software: Making its mark in Ruby on Rails</a>
		            </div>
		            

					
					<div class="paging-older">
						<span class="dark-red">Older</span><span class="decorative-marker">//</span>
			            <a class="paging-link" href="/blog/2007/11/29/ruby-usage-trend-in-indian-cities/">Ruby Usage Trend in Indian Cities</a>
		            </div>
		            
	            </div>
            
          </section>
          
          	<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'rubylearning';
    var disqus_identifier = 'http:\/\/rubylearning.com\/blog\/2007\/11\/30\/akitaonrails-on-anatomy-of-ruby-blocks\/closures\/';
    var disqus_title = '\x22AkitaOnRails\x22 On Anatomy of Ruby Blocks\/Closures';
    var disqus_url = 'http:\/\/rubylearning.com\/blog\/2007\/11\/30\/akitaonrails-on-anatomy-of-ruby-blocks\/closures\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          
        
      <div class="footer">
	<hr class="thin" />
	<div class="pure-menu pure-menu-horizontal pure-menu-open">
		<ul class="footer-menu">
		
		</ul>
	</div>

	<p>&copy; 2015 RubyLearning. All rights reserved. </p>
</div>

    </div>
  </div>
	

	

  
</body>
</html>
